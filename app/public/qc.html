<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Quality Control Review for Medical Imaging">
    <title>QC Review - Medical Imaging QC</title>
    
    <!-- External stylesheets -->
    <link rel="stylesheet" href="common.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
    
    <!-- External scripts -->
    <script src="https://cdn.jsdelivr.net/npm/@niivue/niivue@0.38.0/dist/niivue.umd.js"></script>
    <script src="common.js"></script>
    
    <!-- Module imports -->
    <script type="module">
        import NiivueBuffer from './NiivueBuffer.js';
        window.NiivueBuffer = NiivueBuffer;
    </script>
    
    <style>
        /* QC-specific styles */
        #gl {
            width: 100%;
            height: 100%;
        }
    
        @keyframes quickPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.03); }
        }
    
        .qc-options button.animate {
            animation: quickPulse 0.1s ease;
        }
    
        /* Styles that might need adjustments based on specific QC page layout */
        .content-container {
            flex: 1;
            display: flex;
            overflow: hidden;
        }
    
        .image-panel {
            flex: 1;
            background-color: #000;
            overflow: hidden;
        }
    
        .control-panel {
            flex: 0 0 300px;
            padding: 1rem;
            background-color: var(--secondary-bg);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 1rem; /* Add spacing between elements */
        }
    
        /* Media query for responsive design specific to QC page */
        @media (max-width: 768px) {
            .content-container {
                flex-direction: column;
            }
            .control-panel {
                flex: 0 0 auto;
                width: 100%;
            }
        }

        /* Equal length for buttons */
        .nav-buttons button {
            flex: 1;
        }

        /* Additional styling to reduce clutter */
        .control-group, .opacity-control, .nav-buttons {
            margin-bottom: 1rem;
        }

        .qc-options button {
            width: 100%;
            margin-bottom: 0.5rem;
        }
    </style>
</head>
<body onload="checkAuth(); initializeApp();">
    <div class="page-container">
        <nav class="nav-bar">
            <ul>
                <li><a href="filter.html"><i class="fas fa-home"></i> Home</a></li>
                <li><a href="database.html"><i class="fas fa-database"></i> Database</a></li>
                <li><a href="#" onclick="logout()"><i class="fas fa-sign-out-alt"></i> Logout</a></li>
                <li><i class="fas fa-info-circle info-icon" onclick="openModal()"></i></li>
                <li><span id="userStatus">Logged in as: </span></li>
            </ul>
        </nav>
        <div class="content-container">
            <div class="image-panel">
                <canvas id="gl"></canvas>
            </div>
            <div class="control-panel">
                <div class="patient-info" id="patient-info">Patient: Loading... | Session: Loading...</div>
                <div class="controls">
                    <div class="control-group">
                        <label for="viewMode">View Mode:</label>
                        <select id="viewMode" class="select-styled">
                            <option value="multiplanar">Multiplanar</option>
                            <option value="render">3D Render</option>
                        </select>
                    </div>
                    <div class="opacity-control" id="opacityControl" style="display: none;">
                        <label for="opacitySlider">Mask Opacity:</label>
                        <input type="range" id="opacitySlider" min="0" max="1" step="0.1" value="1">
                    </div>
                </div>
                <div class="qc-options" id="qcOptions">
                    <!-- QC options will be dynamically inserted here -->
                </div>
                <div class="nav-buttons">
                    <button class="button button-secondary" onclick="loadPrevious()"><i class="fas fa-chevron-left"></i> Previous</button>
                    <button class="button button-primary" onclick="loadNext()"><i class="fas fa-chevron-right"></i> Next</button>
                </div>
            </div>
        </div>
        <div id="infoModal" class="modal">
            <div class="modal-content">
                <span class="close" onclick="closeModal()">&times;</span>
                <h2>How to Use This Page</h2>
                <div class="keyboard-controls">
                    <ul>
                        <li><span class="key">&larr;</span> Navigate to previous patient</li>
                        <li><span class="key">&rarr;</span> Navigate to next patient</li>
                        <li><span class="key">&uarr;</span> Move to previous QC option</li>
                        <li><span class="key">&darr;</span> Move to next QC option</li>
                        <li><span class="key">Enter</span> Select highlighted QC option</li>
                    </ul>
                </div>
                <p>Use the arrow keys to navigate between patients and QC options. The currently selected QC option will be highlighted in green. Press Enter to confirm your selection and move to the next patient.</p>
            </div>
        </div>
    </div>
    <div id="status-screen" class="status-screen">
        <div class="status-content">
          <h2>Initializing QC Application</h2>
          <p id="status-message">Loading patient data...</p>
          <div class="loader"></div>
        </div>
    </div>
    <script>
        let nv, niivueBuffer;
        const bufferSize = 7; // Adjust as needed
        const cacheSize = 20; // Adjust as needed
        const workerCount = 7; // Adjust as needed

        let patientSessions = [];
        let currentIndex = 0;
        const sessionId = localStorage.getItem('sessionId');
        const qcType = new URLSearchParams(window.location.search).get('qcType') || 'T1';
        let isLoading = false;

        function showStatusScreen() {
            document.getElementById('status-screen').style.display = 'flex';
        }

        function hideStatusScreen() {
            document.getElementById('status-screen').style.display = 'none';
        }

        function updateStatusMessage(message) {
            document.getElementById('status-message').textContent = message;
        }


        async function initializeApp() {
            showStatusScreen();
            try {
                console.log('Initializing app...');
                updateStatusMessage('Initializing app...');
                initializeNiivue();
                updateStatusMessage('Fetching patient data...');
                await fetchPatientSessions();
                updateStatusMessage('Setting up UI...');
                await addKeyboardListeners();
                console.log('App initialization complete.');
                updateStatusMessage('Initialization complete...')
            } catch (error) {
                console.error("Failed to initialize app:", error);
                alert(`Failed to initialize app: ${error.message}`);
            }
            hideStatusScreen();

        }

        function initializeNiivue() {
            console.log('Initializing Niivue...');
            nv = new niivue.Niivue({
                isResizeCanvas: true,
                dragAndDropEnabled: true,
                sliceType: niivue.SLICE_TYPE.MULTIPLANAR,
                backColor: [0, 0, 0, 1],
                crosshairColor: [1, 0, 0, 0.8],
            });
            nv.attachTo("gl");
            console.log('Niivue initialized.');
        }

        async function fetchPatientSessions() {
            console.log('Fetching patient sessions...');
            try {
                const response = await fetchWithAuth(`/patients-sessions?qcType=${qcType}`);
                const data = await response.json();
                if (data.length > 0) {
                    patientSessions = data;
                    console.log(`Fetched ${patientSessions.length} patient sessions.`);
                    niivueBuffer = new NiivueBuffer(bufferSize, cacheSize, sessionId, workerCount);
                    await niivueBuffer.initialize(patientSessions, qcType);
                    await loadPatientSession(currentIndex);
                } else {
                    throw new Error("No patient sessions found. Please check the server configuration.");
                }
            } catch (error) {
                console.error("Failed to fetch patient sessions:", error);
                alert(`Failed to fetch patient sessions: ${error.message}`);
            }
        }

        async function loadPatientSession(index) {
            // console.log(`Loading patient session for index: ${index}`);
            try {
                if (index < 0 || index >= patientSessions.length) {
                    throw new Error("Invalid patient session index");
                }

                const { patient, session } = patientSessions[index];
                document.getElementById("patient-info").textContent = `Patient: ${patient} | Session: ${session}`;

                const volumes = await niivueBuffer.getImage(index);
                if (volumes && volumes.length > 0) {
                    console.log(`Loaded ${volumes.length} volumes for index ${index}`);
                    await nv.loadVolumes(volumes);
                    nv.setSliceType(nv.sliceTypeMultiplanar);
                    nv.updateGLVolume();
                    document.getElementById('opacityControl').style.display = qcType === 'LST_AI' ? 'block' : 'none';
                    updateQCOptions();
                    await fetchAndHighlightPreviousQCOption(patient, session, qcType);
                } else {
                    throw new Error("No image data found for this patient session");
                }
            } catch (error) {
                console.error("Failed to load patient session:", error);
                alert(`Failed to load patient session: ${error.message}`);
                // Try to load the next session if this one fails
                await loadNext();
            }
        }


        function updateQCOptions() {
            const qcOptionsDiv = document.getElementById('qcOptions');
            qcOptionsDiv.innerHTML = '';
            const options = qcType === 'LST_AI' ? ['Good', 'Bad'] : ['Ideal image', 'Gadolinium', 'Severe artefacts', 'Incorrect weighting', 'Corrupted image'];

            options.forEach(option => {
                const button = document.createElement('button');
                button.textContent = option;
                button.className = `button ${qcType === 'LST_AI' ? option.toLowerCase() + '-button' : ''}`;
                button.onclick = () => logQCOption(option).then(() => loadNext());
                qcOptionsDiv.appendChild(button);
            });

            // Set default option if no option is already selected
            if (!document.querySelector('.qc-options .button.selected')) {
                let defaultOption = qcType === 'LST_AI' ? 'Good' : 'Ideal image';
                highlightSelectedOption(defaultOption, false);
            }
        }

        async function fetchAndHighlightPreviousQCOption(patient, session, qcType) {
            try {
                const response = await fetchWithAuth(`/get-qc-log?patient=${patient}&session=${session}&qcType=${qcType}`);
                const data = await response.json();
                selectedOption = data.option || (qcType === 'LST_AI' ? 'Good' : 'Ideal image');
                highlightSelectedOption(selectedOption, false);
            } catch (error) {
                console.error("Error fetching QC log:", error);
                selectedOption = qcType === 'LST_AI' ? 'Good' : 'Ideal image';
                highlightSelectedOption(selectedOption, false);
            }
        }

        function highlightSelectedOption(option, animate = true) {
            // console.log(`Highlighting option: ${option}`);
            const buttons = document.querySelectorAll('.qc-options .button');
            buttons.forEach(button => {
                if (button.textContent === option) {
                    button.classList.add('selected');
                    if (animate) {
                        button.classList.add('animate');
                        setTimeout(() => button.classList.remove('animate'), 200);
                    }
                } else {
                    button.classList.remove('selected', 'animate');
                }
            });
        }

        async function logQCOption(option) {
            const { patient, session } = patientSessions[currentIndex];
            highlightSelectedOption(option, true);

            try {
                const response = await fetchWithAuth('/log-qc', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        patientID: patient,
                        sessionID: session,
                        option,
                        qcType,
                        date: new Date().toISOString().split('T')[0],
                        time: new Date().toTimeString().split(' ')[0]
                    })
                });
                const result = await response.json();
                if (!result.success) {
                    throw new Error('Failed to log QC option');
                }
                console.log(`QC option logged: ${option}`);
            } catch (error) {
                console.error('Error logging QC option:', error);
                alert(`Failed to log QC option: ${error.message}`);
            }
        }

        async function loadNext() {
            if (isLoading) return;
            isLoading = true;

            try {
                // console.log('Loading next image...');
                if (!niivueBuffer) {
                    throw new Error("Image loading system not initialized");
                }

                currentIndex = await niivueBuffer.moveNext();
                await loadPatientSession(currentIndex);
            } catch (error) {
                console.error("Failed to load next image:", error);
                alert(`Failed to load next image: ${error.message}`);
            } finally {
                isLoading = false;
            }
        }

        async function loadPrevious() {
            if (isLoading) return;
            isLoading = true;

            try {
                // console.log('Loading previous image...');
                if (!niivueBuffer) {
                    throw new Error("Image loading system not initialized");
                }

                currentIndex = await niivueBuffer.movePrevious();
                await loadPatientSession(currentIndex);
            } catch (error) {
                console.error("Failed to load previous image:", error);
                alert(`Failed to load previous image: ${error.message}`);
            } finally {
                isLoading = false;
            }
        }

        function addKeyboardListeners() {
            document.addEventListener('keydown', (e) => {
                switch(e.key) {
                    case 'ArrowLeft': loadPrevious(); break;
                    case 'ArrowRight': loadNext(); break;
                    case 'ArrowUp':
                    case 'ArrowDown':
                        const buttons = document.querySelectorAll('.qc-options .button');
                        const currentIndex = Array.from(buttons).findIndex(b => b.classList.contains('selected'));
                        let newIndex = e.key === 'ArrowUp' ? currentIndex - 1 : currentIndex + 1;
                        if (newIndex < 0) newIndex = buttons.length - 1;
                        if (newIndex >= buttons.length) newIndex = 0;
                        highlightSelectedOption(buttons[newIndex].textContent, true);
                        break;
                    case 'Enter':
                        const selectedOption = document.querySelector('.qc-options .button.selected');
                        if (selectedOption) {
                            logQCOption(selectedOption.textContent).then(() => loadNext());
                        }
                        break;
                }
            });
        }


        function openModal() {
            document.getElementById('infoModal').style.display = 'block';
        }

        function closeModal() {
            document.getElementById('infoModal').style.display = 'none';
        }

        window.onclick = function(event) {
            if (event.target == document.getElementById('infoModal')) {
                closeModal();
            }
        }

        document.getElementById('viewMode').addEventListener('change', (e) => {
            if (e.target.value === 'multiplanar') {
                nv.setSliceType(nv.sliceTypeMultiplanar);
            } else {
                nv.setSliceType(nv.sliceTypeRender);
            }
            nv.updateGLVolume();
        });

        document.getElementById('opacitySlider').addEventListener('input', function(e) {
            if (nv.volumes.length > 1) {
                nv.volumes[1].opacity = parseFloat(e.target.value);
                nv.updateGLVolume();
            }
        });
</script>
</body>
</html>